## 11.4 *dres()：观测方程的构建

本章节主要分析 `zdres()`、`ddres()` 和它们所调用的函数，其中部分内容与第 10 章的内容有所重复，因此这里不再赘述，例如 `geodist()`，`satazel()`，`satexclude()` 等函数。

### 11.4.1 zdres()：非差残差

<img style="width: 100%; margin: 20px auto; display: block;" src="https://raw.githubusercontent.com/salmoshu/Winchell-ImgBed/main/img/20250714-013940.jpg"/>
<p style="text-align: center; font-family: 'Microsoft YaHei', SimSun, Arial, sans-serif; font-size: 14px;">图11.2-2 zdres() 函数调用</p>

非差残差（Zero-Difference Residuals），相当于直接使用未做差的原始观测数据进行残差的计算。这里的残差可以简单的记作：OMC（Observation Minus Computed，观测值减去估计值），观测的估计量在整个过程中的修正包括潮汐修正（可选项）、卫星钟差修正、对流层修正，以及接收机天线偏移误差。

**1. 参数列表**

```c
/* args */
int       base     I   0表示接收机，1表示基站
obsd_t   *obs      I   obs观测数据
int       n        I   obs的数量
double   *rs       I   卫星位置和速度，长度为6*n，{x,y,z,vx,vy,vz}(ecef)(m,m/s)
double   *dts      I   卫星钟差，长度为2*n， {bias,drift} (s|s/s)
int      *svh      I   卫星健康标志 (-1:correction not available)
nav_t    *nav      I   NAV导航数据
double   *rr       I   接收机/基站的位置和速度，长度为6*n，{x,y,z,vx,vy,vz}(ecef)(m,m/s)
prcopt_t *opt      I   处理过程选项
int       index    I   0表示接收机，1表示基站，与参数 base 重复了
double   *y        O   相位/伪距残差
double   *e        O   观测矢量 (ecef)
double   *azel     O   方位角和俯仰角 (rad)
double   *freq     O   载波频率
/* return */
return    status   -   1表示成功，0表示失败
```

**2. 执行流程**

* 若没有接收机位置，return 0 
* 接收机位置（ECEF-XYZ）传给`rr_`
* 若需要**地球潮校正**，调用`tidedisp()`对`rr_`进行校正
* 调用`ecef2pos()`将XYZ的`rr_`转为LLH的`pos`
* for循环遍历所有观测值（卫星）：
  * 调用`geodist()`根据卫星位置和接收机位置计算卫地距`r`，和和接收机到卫星的单位向量`e+i*3`，并进行**地球自转改正**。
  * 调用`satazel()`计算卫星方位角、高度角`azel+i*2`，排除小于截止高度角`opt->elmin`的观测值。
  * 对卫地距进行卫星钟差距离改正`r+=-CLIGHT*dts[i*2]`
  * 调用`tropmodel()`利用**Saastamoinen模型**只改正对流层干延迟`zhd`（由于湿度值传0，高度角传0，只计算了天顶方向干延迟 ），湿分量会在之后的ddres（计算双差残差的函数）函数中进行扣除 ，调用`tropmapf()`计算出干延迟投影系数（即天顶方向到接收机相对卫星观测方向上的对流层延迟投影系数）。`tropmodel()`计算出的**天顶对流层干延迟**与`tropmapf()`计算出**干延迟投影系数**相乘，从而得到接收机相对卫星观测方向上的对流层延迟 ，对卫地距进行干延迟改正`r+=tropmapf(obs[i].time,pos,azel+i*2,NULL)*zhd;`
  * 由于之后会计算双差后的残差，因此在短基线的情况下，大部分电离层误差已经得到了消除，所以未进行电离层误差修正；而对流层误差受基站和移动站之间的高度差影响，因此通常还需要进行考虑。
  * 调用`antmodel()`计算接收机天线相位中心改正值`dant`，对每一个频率都有一个值。相对定位只需要计算**接收机**端的天线相位中心修正值。这是由于，相对定位进行单差时，已经将卫星端的天线误差消除了。
  * 调用`zdres_sat()`观测值减经过上述各项改正后的计算值，得到最终的非差残差存到数组`y[]`。**消电离层组合**也在次函数实现。

**3. 源码注释**
::: details 点击查看完整代码
```c
static int zdres(int base, const obsd_t *obs, int n, const double *rs,
                 const double *dts, const double *var, const int *svh,
                 const nav_t *nav, const double *rr, const prcopt_t *opt,
                 int index, double *y, double *e, double *azel, double *freq)
{
    double r,rr_[3],pos[3],dant[NFREQ]={0},disp[3];
    double zhd,zazel[]={0.0,90.0*D2R};
    int i,nf=NF(opt);
    
    trace(3,"zdres   : n=%d\n",n);
    
    for (i=0;i<n*nf*2;i++) y[i]=0.0;
    //若没有接收机位置，return 0
    if (norm(rr,3)<=0.0) return 0; /* no receiver position */
    
    for (i=0;i<3;i++) rr_[i]=rr[i]; //接收机位置传给 rr_
    //若需要地球潮校正，调用 tidedisp 对 rr_ 进行校正。地球潮包含固体潮、极潮和海潮负荷
    /* earth tide correction */
    if (opt->tidecorr) {
        tidedisp(gpst2utc(obs[0].time),rr_,opt->tidecorr,&nav->erp,
                 opt->odisp[base],disp);
        for (i=0;i<3;i++) rr_[i]+=disp[i];
    }
    ecef2pos(rr_,pos);  //rr_ : XYZ->LLH
    
    //遍历观测量
    for (i=0;i<n;i++) {
        //根据卫星位置和接收机位置计算卫地距，并进行地球自转改正
        /* compute geometric-range and azimuth/elevation angle */
        if ((r=geodist(rs+i*6,rr_,e+i*3))<=0.0) continue;
        if (satazel(pos,e+i*3,azel+i*2)<opt->elmin) continue;
        
        /* excluded satellite? */   //排除需要排除的卫星
        if (satexclude(obs[i].sat,var[i],svh[i],opt)) continue;
        
        //对卫地距进行卫星钟差距离改正r
        /* satellite clock-bias */
        r+=-CLIGHT*dts[i*2];
        
        //对卫地距进行对流层延迟改正。对流层延迟可分为大概90%的干延迟和10%的湿延迟，
        //RTKLIB内利用Saastamoinen模型只改正了对流层的干延迟，湿延迟通过随机游走估计的方式进行改正。
        //此处湿度传0，湿延迟计算出的结果就是0
        //当然，建议对这一部分进行算法改进，利用GPT2_w等经验模型改正对流层的总延迟
        /* troposphere delay model (hydrostatic) */
        zhd=tropmodel(obs[0].time,pos,zazel,0.0);
        r+=tropmapf(obs[i].time,pos,azel+i*2,NULL)*zhd;
        
        //接收机天线相位中心改正，调用 antmodel 计算校正值 dant（对每一个频率都有一个值）
        /* receiver antenna phase center correction */
        antmodel(opt->pcvr+index,opt->antdel[index],azel+i*2,opt->posopt[1],
                 dant);

        //观测值减经过上述各项改正后的计算值，
        //得到最终的非差闭合差v。此处涉及到无电离层组合观测值的求解。
        /* UD phase/code residual for satellite */
        zdres_sat(base,r,obs+i,nav,azel+i*2,dant,opt,y+i*nf*2,freq+i*nf);
    }
    trace(4,"rr_=%.3f %.3f %.3f\n",rr_[0],rr_[1],rr_[2]);
    trace(4,"pos=%.9f %.9f %.3f\n",pos[0]*R2D,pos[1]*R2D,pos[2]);
    for (i=0;i<n;i++) {
        trace(4,"sat=%2d %13.3f %13.3f %13.3f %13.10f %6.1f %5.1f\n",
              obs[i].sat,rs[i*6],rs[1+i*6],rs[2+i*6],dts[i*2],azel[i*2]*R2D,
              azel[1+i*2]*R2D);
    }
    trace(4,"y=\n"); tracemat(4,y,nf*2,n,13,3);
    
    return 1;
}
```
:::

### 11.4.2 zdres_sat()：计算一个站心非差残差

计算接收机或基站对某一颗卫星的非差残差，在此实现消电离层组合。

**传入参数**：

```c
int      base      I   0表示接收机，1表示基站
double   r         I   经过钟差和对流层校正后的几何距离
obsd_t   *obs      I   obs观测数据
nav_t    *nav      I   NAV导航数据
double   *azel     I   方位角和俯仰角 (rad)
double   *dant     I   接收机天线校正值
prcopt_t *opt      I   处理过程选项
double   *y        O   非差闭合差
double   *freq	   O   载波频率
```
**执行流程**：

* 如果是消电离层组合`IONOOPT_IFLC`

  ![](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/d96fdfdc1a3c4ed397a5b0a299c81d01.png)


  * 调用`sat2freq()`获取观测值`obs->code[0]`、`obs->code[1]`的频率`freq1`、`freq2`
  * 调用`testsnr()`检测信噪比是否都小于`opt->snrmask`
  * 计算消电离层组合系数`c1`、`c2`
  * 计算天线校正值`dant_if`
  * 计算载波相位残差`y[0]`，伪距残差`y[1]`，残差 = IFLC观测量 - 卫地距 - 天线偏移量 
  * `freq[0]=1.0`

* 不是消电离层组合的情况，for循环遍历`obs`所有频率值，都计算残差
  * 调用`sat2freq()`获取`obs->code[i]`频率`freq[i]`
  * 调用`testsnr()`检测信噪比是否小于`opt->snrmask`
  * 计算载波相位残差`y[i]`，伪距残差`y[i+nf]`，残差 = 观测量 - 卫地距 - 天线偏移量 

```c
static void zdres_sat(int base, double r, const obsd_t *obs, const nav_t *nav,
                      const double *azel, const double *dant,
                      const prcopt_t *opt, double *y, double *freq)
{
    double freq1,freq2,C1,C2,dant_if;
    int i,nf=NF(opt);
    
    //电离层校正模式为 IONOOPT_IFLC 的情况
    if (opt->ionoopt==IONOOPT_IFLC) { /* iono-free linear combination */
        //获取观测值obs->code[0]、obs->code[1]的频率freq1、freq2
        freq1=sat2freq(obs->sat,obs->code[0],nav);  
        freq2=sat2freq(obs->sat,obs->code[1],nav);
        if (freq1==0.0||freq2==0.0) return;
        //检测信噪比
        if (testsnr(base,0,azel[1],obs->SNR[0]*SNR_UNIT,&opt->snrmask)||
            testsnr(base,1,azel[1],obs->SNR[1]*SNR_UNIT,&opt->snrmask)) return;
        //计算消电离层组合系数c1、c2    (E.5.23)
        C1= SQR(freq1)/(SQR(freq1)-SQR(freq2));
        C2=-SQR(freq2)/(SQR(freq1)-SQR(freq2));
        //计算天线校正值 dant_if
        dant_if=C1*dant[0]+C2*dant[1];
        //计算残差，残差 = IFLC观测量 - 卫地距 - 天线偏移量 
        if (obs->L[0]!=0.0&&obs->L[1]!=0.0) {   //载波相位残差  (E.5.22) 
            y[0]=C1*obs->L[0]*CLIGHT/freq1+C2*obs->L[1]*CLIGHT/freq2-r-dant_if;
        }
        if (obs->P[0]!=0.0&&obs->P[1]!=0.0) {   //伪距残差  (E.5.21) 
            y[1]=C1*obs->P[0]+C2*obs->P[1]-r-dant_if;
        }
        freq[0]=1.0;
    }
    //电离层校正模式不为 IONOOPT_IFLC 的情况
    else {
        for (i=0;i<nf;i++) {
            if ((freq[i]=sat2freq(obs->sat,obs->code[i],nav))==0.0) continue;
            //检测信噪比
            /* check SNR mask */
            if (testsnr(base,i,azel[1],obs->SNR[i]*SNR_UNIT,&opt->snrmask)) {
                continue;
            }
            //计算残差，残差 = IFLC观测量 - 卫地距 - 天线偏移量 
            /* residuals = observable - pseudorange */
            if (obs->L[i]!=0.0) y[i   ]=obs->L[i]*CLIGHT/freq[i]-r-dant[i];
            if (obs->P[i]!=0.0) y[i+nf]=obs->P[i]               -r-dant[i];
        }
    }
}
```

### 11.4.3 ddres()：计算双差残差、设计矩阵、新息向量

![image-20241006144647874](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20241006144647874.png)

站星双差、矩阵v、双差设计矩阵`H`，双差协方差矩阵`R`。

**1. 双差理论**

**a. 单差、双差的概念**

![](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/1f3ade17ced34b49bf6b125f3a56cf06.png)

**b. 双差残差、设计矩阵**

> 摘自：[RTKLIB相对定位部分算法梳理](http://t.csdn.cn/vpqQi)

**非差残差** = 观测 - 卫地距(此处卫地距包含误差，即：`卫地距 = 真实卫地距 + 单位视线向量e * delta_r `) ，然后**站间单差星间双差**，完成H阵前三列与状态x前三项的乘法计算。后续继续**减去双差模糊度**，就完成了`v = Hx - Z`的计算，即**新息向量**。
![](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/5e632e7d6a3342719f4b2e1752b25286.png)

**2. 传入参数**

```c
rtk_t    *rtk      IO  rtk控制结构体
nav_t    *nav      I   导航数据
double   dt        I   接收机和基站的时间差
double   *x        IO  状态变量
double   *P        IO  状态变量的误差协方差阵
int      sat       I   接收机和基站共同观测的卫星号列表
double   *y        IO  相位/伪距残差
double   *e        IO  观测矢量 (ecef)
double   *azel     O   方位角和俯仰角 (rad)
int      *iu       I   接收机和基站共同观测的卫星在接收机观测值中的index值列表
int      *ir       I   接收机和基站共同观测的卫星在基站观测值中的index值列表
int      ns        I   接收机和基站共同观测的卫星个数
double   *v        O   实际观测量与预测观测量的残差（双差观测值新息向量）
double   *R        O   测量误差的协方差
double   *H        O   观测矩阵
int      *vflg     O   数据有效标志
```
**3. 执行流程**

* 计算**基线**长度`bl`，基线向量`dr`
* 调用`ecef2pos()`，计算基准站、流动站**LLH**坐标`posu`、`posr`
* for循环，遍历每一个卫星、每一个频率，所有伪距残差`rtk->ssat[i].resp[j]`、载波相位残差`rtk->ssat[i].resc[j]`重置为0 
* 遍历所有共视卫星

  * 电离层模式>=`IONOOPT_EST`，调用`ionmapf()`计算电离层延迟因子，`im[i]`取基准站、流动站的平均
  * 对流层模式>=`TROPOPT_EST`，调用`prectrop()`计算对流层延迟因子，流动站`tropu[i]`、基准站`tropr[i]`
* 遍历所有系统`for (m=0;m<6;m++)`
* 遍历所有频率`for (f=opt->mode>PMODE_DGPS?0:nf;f<nf*2;f++)`；若为`PMODE_DGPS`伪距双差，需要限制遍历范围， 载波相位在`0-nf`，`nf-2nf`为伪距，因此伪距差分定位从`nf`开始

  * 寻找仰角最高的卫星作为**参考卫星**，选取失败则continue
  * 将`H+nv*rtk->nx`的地址赋给`H`，此时更改`Hi`中的值即更改H矩阵中的值 
  * **双差残差**`v[nv]`计算：【参考星(移动站) - 参考星(基准站)】- 【非参考星(移动站) - 非参考星(基准站)】 
  * 构建**设计矩阵**`H` ，移动站非参考星视线向量 - 移动站参考星视线向量
  * 若要估计**电离层**参数，模式`IONOOPT_EST`，用电离层延迟因子修正v和H
  * 若要估计**对流层**参数，模式`TROPOPT_EST`，用对流层延迟因子修正v和H 
  * 用**单差模糊度**参数修正`v`和`H`
  * 将双差载波残差存到`rtk->ssat[sat[j]-1].resc[f   ]`、双差伪距残差存到`rtk->ssat[sat[j]-1].resp[f-nf]`
  * **新息判断**，残差与设置新息值进行判断，根据选项maxinno的值检测是否要排除此观测数据 
  * 计算**单差协方差**`Ri`、`Rj `
  * 设置**数据有效标志**`vlfg`
* 如果是动基线模式，`constbl()`增加**基线长度约束** 
* 调用`ddcov()`，计算载波相位/伪距**双差量测噪声协方差阵**`R`
* 释放内存，返回有效数据数`nv`

**4. 源码注释**

::: details 点击查看完整代码
```c
static int ddres(rtk_t *rtk, const nav_t *nav, double dt, const double *x,
                 const double *P, const int *sat, double *y, double *e,
                 double *azel, double *freq, const int *iu, const int *ir,
                 int ns, double *v, double *H, double *R, int *vflg)
{
    prcopt_t *opt=&rtk->opt;
    double bl,dr[3],posu[3],posr[3],didxi=0.0,didxj=0.0,*im;
    double *tropr,*tropu,*dtdxr,*dtdxu,*Ri,*Rj,freqi,freqj,*Hi=NULL;
    int i,j,k,m,f,nv=0,nb[NFREQ*4*2+2]={0},b=0,sysi,sysj,nf=NF(opt);
    
    trace(3,"ddres   : dt=%.1f nx=%d ns=%d\n",dt,rtk->nx,ns);
    
    bl=baseline(x,rtk->rb,dr);  //计算基线长度bl，基线向量dr
    ecef2pos(x,posu); ecef2pos(rtk->rb,posr);   //基准站、流动站 XYZ-LLH
    
    Ri=mat(ns*nf*2+2,1); Rj=mat(ns*nf*2+2,1); im=mat(ns,1);
    tropu=mat(ns,1); tropr=mat(ns,1); dtdxu=mat(ns,3); dtdxr=mat(ns,3);
    
    for (i=0;i<MAXSAT;i++) for (j=0;j<NFREQ;j++) {
        rtk->ssat[i].resp[j]=rtk->ssat[i].resc[j]=0.0;  //所有伪距残差、载波相位残差重置为0
    }
    /* compute factors of ionospheric and tropospheric delay */     
    for (i=0;i<ns;i++) {
        //若 电离层模式>=IONOOPT_EST，调用 ionmapf() 计算电离层延迟因子
        //基准站、流动站，im[i]取基准站、流动站的平均
        if (opt->ionoopt>=IONOOPT_EST) {    
            im[i]=(ionmapf(posu,azel+iu[i]*2)+ionmapf(posr,azel+ir[i]*2))/2.0;
        }
        //若 对流层模式>=TROPOPT_EST，调用 prectrop() 计算对流层延迟因子
        //流动站tropu[i]、基准站tropr[i]
        if (opt->tropopt>=TROPOPT_EST) {    
            tropu[i]=prectrop(rtk->sol.time,posu,0,azel+iu[i]*2,opt,x,dtdxu+i*3);
            tropr[i]=prectrop(rtk->sol.time,posr,1,azel+ir[i]*2,opt,x,dtdxr+i*3);
        }
    }
    
    // 遍历不同系统
    for (m=0;m<6;m++) /* m=0:GPS/SBS,1:GLO,2:GAL,3:BDS,4:QZS,5:IRN */    
    //遍历每一个频率，计算双差残差
    //若为PMODE_DGPS伪距双差，需要限制遍历范围， 载波相位在0-nf，nf至2nf为伪距，因此伪距差分定位从nf开始
    for (f=opt->mode>PMODE_DGPS?0:nf;f<nf*2;f++) {
        //寻找仰角最高的卫星作为参考卫星
        /* search reference satellite with highest elevation */ 
        for (i=-1,j=0;j<ns;j++) {
            sysi=rtk->ssat[sat[j]-1].sys;   
            if (!test_sys(sysi,m)) continue;
            if (!validobs(iu[j],ir[j],f,nf,y)) continue;
            if (i<0||azel[1+iu[j]*2]>=azel[1+iu[i]*2]) i=j;
        }
        if (i<0) continue;  //选取失败则continue
        
        //遍历所有卫星，计算双差
        /* make DD (double difference) */
        for (j=0;j<ns;j++) {
            if (i==j) continue;
            sysi=rtk->ssat[sat[i]-1].sys;
            sysj=rtk->ssat[sat[j]-1].sys;
            freqi=freq[f%nf+iu[i]*nf];
            freqj=freq[f%nf+iu[j]*nf];
            if (!test_sys(sysj,m)) continue;
            if (!validobs(iu[j],ir[j],f,nf,y)) continue;

            //用传入的非差相位/伪距残差y计算双差残差v，并计算对应的H
            if (H) {    
                //将H+nv*rtk->nx的地址赋给H，此时更改Hi中的值即更改H矩阵中的值
                Hi=H+nv*rtk->nx;
                for (k=0;k<rtk->nx;k++) Hi[k]=0.0;
            }
            //双差残差计算
            //【参考星(移动站) - 参考星(基准站)】- 【非参考星(移动站) - 非参考星(基准站)】
            /* DD residual */
            v[nv]=(y[f+iu[i]*nf*2]-y[f+ir[i]*nf*2])-    
                  (y[f+iu[j]*nf*2]-y[f+ir[j]*nf*2]);
            
            //移动站位置偏导
            //移动站非参考星视线向量 - 移动站参考星视线向量
            /* partial derivatives by rover position */     
            if (H) {
                for (k=0;k<3;k++) {
                    Hi[k]=-e[k+iu[i]*3]+e[k+iu[j]*3];   //每一行前3列为观测向量差
                }
            }

            //若要估计电离层参数，模式IONOOPT_EST，用电离层延迟因子修正v和H
            //注意伪距和载波相位的电离层延迟大小相同，但是符号相反
            /* DD ionospheric delay term */
            if (opt->ionoopt==IONOOPT_EST) {    
                didxi=(f<nf?-1.0:1.0)*im[i]*SQR(FREQ1/freqi);   //载波相位为负
                didxj=(f<nf?-1.0:1.0)*im[j]*SQR(FREQ1/freqj);   //伪距为正
                v[nv]-=didxi*x[II(sat[i],opt)]-didxj*x[II(sat[j],opt)];
                if (H) {
                    Hi[II(sat[i],opt)]= didxi;
                    Hi[II(sat[j],opt)]=-didxj;
                }
            }

            //若要估计对流层参数，模式TROPOPT_EST，用对流层延迟因子修正v和H
            /* DD tropospheric delay term */
            if (opt->tropopt==TROPOPT_EST||opt->tropopt==TROPOPT_ESTG) {
                v[nv]-=(tropu[i]-tropu[j])-(tropr[i]-tropr[j]);
                for (k=0;k<(opt->tropopt<TROPOPT_ESTG?1:3);k++) {
                    if (!H) continue;
                    Hi[IT(0,opt)+k]= (dtdxu[k+i*3]-dtdxu[k+j*3]);
                    Hi[IT(1,opt)+k]=-(dtdxr[k+i*3]-dtdxr[k+j*3]);
                }
            }

            //用相位偏移修正v和H
            //如果不是无电离层组合，
            //从载波相位双差残差中扣除双差模糊度部分（即phase-bias），
            //并对H矩阵中和模糊度相关的部分进行赋值
            /* DD phase-bias term */
            if (f<nf) {
                if (opt->ionoopt!=IONOOPT_IFLC) {
                    v[nv]-=CLIGHT/freqi*x[IB(sat[i],f,opt)]-
                           CLIGHT/freqj*x[IB(sat[j],f,opt)];
                    if (H) {
                        Hi[IB(sat[i],f,opt)]= CLIGHT/freqi;
                        Hi[IB(sat[j],f,opt)]=-CLIGHT/freqj;
                    }
                }
                else {
                    v[nv]-=x[IB(sat[i],f,opt)]-x[IB(sat[j],f,opt)];
                    if (H) {
                        Hi[IB(sat[i],f,opt)]= 1.0;
                        Hi[IB(sat[j],f,opt)]=-1.0;
                    }
                }
            }
            //将双差载波，伪距残差，输出到相应的结构体中
            if (f<nf) rtk->ssat[sat[j]-1].resc[f   ]=v[nv];
            else      rtk->ssat[sat[j]-1].resp[f-nf]=v[nv];
            
            //根据选项maxinno的值检测是否要排除此观测数据
            /* test innovation */
            if (opt->maxinno>0.0&&fabs(v[nv])>opt->maxinno) {
                if (f<nf) {
                    rtk->ssat[sat[i]-1].rejc[f]++;
                    rtk->ssat[sat[j]-1].rejc[f]++;
                }
                errmsg(rtk,"outlier rejected (sat=%3d-%3d %s%d v=%.3f)\n",
                       sat[i],sat[j],f<nf?"L":"P",f%nf+1,v[nv]);
                continue;
            }

            //计算单差的测量误差协方差Ri、i为参考星，j为非参考星
            /* SD (single-differenced) measurement error variances */
            Ri[nv]=varerr(sat[i],sysi,azel[1+iu[i]*2],bl,dt,f,opt);
            Rj[nv]=varerr(sat[j],sysj,azel[1+iu[j]*2],bl,dt,f,opt);
            
            //设置数据有效标志，首先是载波，然后是伪距；根据f<nf判断
            /* set valid data flags */
            if (opt->mode>PMODE_DGPS) {
                if (f<nf) rtk->ssat[sat[i]-1].vsat[f]=rtk->ssat[sat[j]-1].vsat[f]=1;
            }
            else {
                rtk->ssat[sat[i]-1].vsat[f-nf]=rtk->ssat[sat[j]-1].vsat[f-nf]=1;
            }
            trace(4,"sat=%3d-%3d %s%d v=%13.3f R=%8.6f %8.6f\n",sat[i],
                  sat[j],f<nf?"L":"P",f%nf+1,v[nv],Ri[nv],Rj[nv]);
            
            vflg[nv++]=(sat[i]<<16)|(sat[j]<<8)|((f<nf?0:1)<<4)|(f%nf);
            nb[b]++;
        }
        b++;
    }
    /* end of system loop */
    
    //如果是动基线的模式，增加基线长度约束
    /* baseline length constraint for moving baseline */
    if (opt->mode==PMODE_MOVEB&&constbl(rtk,x,P,v,H,Ri,Rj,nv)) {
        vflg[nv++]=3<<4;
        nb[b++]++;
    }
    if (H) {trace(5,"H=\n"); tracemat(5,H,rtk->nx,nv,7,4);}
    
    //调用ddcov()，计算载波相位/伪距双差量测噪声协方差阵R
    /* DD measurement error covariance */
    ddcov(nb,b,Ri,Rj,nv,R);
    
    free(Ri); free(Rj); free(im);
    free(tropu); free(tropr); free(dtdxu); free(dtdxr);
    
    return nv;
}
```
:::

### 11.4.5 ionmapf()：SLM(Single-Layer Model)投影映射模型

![](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/cba6d457002942348502efe8e261f4af.png)


```c
extern double ionmapf(const double *pos, const double *azel)
{
    if (pos[2]>=HION) return 1.0;   //如果接收机比电离层还高，return 1
    return 1.0/cos(asin((RE_WGS84+pos[2])/(RE_WGS84+HION)*sin(PI/2.0-azel[1])));
}
```

### 11.4.6 prectrop()：精密对流层模型

**1. 参数列表**

```c
I      gtime_t time     当前历元时间
I      double *pos      基站/移动站位置：纬、经、高
I      int r            0表示移动站，1表示基站，用来计算对流层状态量在卡尔曼滤波状态矢量的索引
I      double *azel     高度角，方位角
I      prcopt_t *opt    处理选项
I      double *x        卡尔曼滤波状态矢量
IO     double *dtdx     对流层湿分量、北向和东向梯度因子
```

**2. 源码注释**

::: details 点击查看完整代码
```c
static double prectrop(gtime_t time, const double *pos, int r,
                       const double *azel, const prcopt_t *opt, const double *x,
                       double *dtdx)
{
    double m_w=0.0,cotz,grad_n,grad_e;
    int i=IT(r,opt);
    
    /* wet mapping function */
    tropmapf(time,pos,azel,&m_w);   //计算干湿延迟投影系数
    
    if (opt->tropopt>=TROPOPT_ESTG&&azel[1]>0.0) {
        
        /* m_w=m_0+m_0*cot(el)*(Gn*cos(az)+Ge*sin(az)): ref [6] */
        cotz=1.0/tan(azel[1]);
        grad_n=m_w*cotz*cos(azel[0]);
        grad_e=m_w*cotz*sin(azel[0]);
        m_w+=grad_n*x[i+1]+grad_e*x[i+2];
        dtdx[1]=grad_n*x[i];
        dtdx[2]=grad_e*x[i];
    }
    else dtdx[1]=dtdx[2]=0.0;
    dtdx[0]=m_w;
    return m_w*x[i];
}
```
:::

### 11.4.7 constbl()：动基线约束

动基线模式：流动站、基准站都在移动，**相对距离保持不变**，基准站位置由SPP得来，流动站位置由短基线相对定位得到，**只有相对位置有意义**，绝对位置就是单点定位的精度。

![](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/3b0f29bb0e9a4558bdb6fbe343a83b78.png)

::: details 点击查看完整代码
```c
static int constbl(rtk_t *rtk, const double *x, const double *P, double *v,
                   double *H, double *Ri, double *Rj, int index)
{
    const double thres=0.1; /* threshold for nonliearity (v.2.3.0) */
    double xb[3],b[3],bb,var=0.0;
    int i;
     
    trace(3,"constbl : \n");
    
    /* no constraint */
    if (rtk->opt.baseline[0]<=0.0) return 0;
    
    //
    /* time-adjusted baseline vector and length */
    for (i=0;i<3;i++) {
        xb[i]=rtk->rb[i];
        b[i]=x[i]-xb[i];
    }
    bb=norm(b,3);   
    
    //var为单点定位方差阵p的平均
    /* approximate variance of solution */
    if (P) {
        for (i=0;i<3;i++) var+=P[i+i*rtk->nx];
        var/=3.0;
    }
    //检查方差非线性化的程度，var>SQR(thres*bb)，就return
    /* check nonlinearity */
    if (var>SQR(thres*bb)) {
        trace(3,"constbl : equation nonlinear (bb=%.3f var=%.3f)\n",bb,var);
        return 0;
    }

    /* constraint to baseline length */
    v[index]=rtk->opt.baseline[0]-bb;
    if (H) {
        for (i=0;i<3;i++) H[i+index*rtk->nx]=b[i]/bb;
    }
    Ri[index]=0.0;
    Rj[index]=SQR(rtk->opt.baseline[1]);
    
    trace(4,"baseline len   v=%13.3f R=%8.6f %8.6f\n",v[index],Ri[index],Rj[index]);
    
    return 1;
}
```
:::

### 11.4.8 ddcov()：计算双差量测噪声协方差阵 

根据之前计算的**单差协方差**`Ri`、`Rj `来计算，`i==j`时为`Ri[k+i]+Rj[k+i]`，`i!=j`时为`Ri[k+i]`

::: details 点击查看完整代码
```c
static void ddcov(const int *nb, int n, const double *Ri, const double *Rj,
                  int nv, double *R)
{
    int i,j,k=0,b;
    
    trace(3,"ddcov   : n=%d\n",n);
    
    for (i=0;i<nv*nv;i++) R[i]=0.0;
    for (b=0;b<n;k+=nb[b++]) {
        
        for (i=0;i<nb[b];i++) for (j=0;j<nb[b];j++) {
            R[k+i+(k+j)*nv]=Ri[k+i]+(i==j?Rj[k+i]:0.0);     //i==j时为Ri[k+i]+Rj[k+i]，i!=j时为Ri[k+i]
        }
    }
    trace(5,"R=\n"); tracemat(5,R,nv,nv,8,6);
}
```
:::

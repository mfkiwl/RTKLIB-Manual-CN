## 11.6 *amb(): 模糊度固定

### 11.6.1 整周模糊度固定

**1. 概述**

在以载波相位观测量为根据进行精密相对定位时，整周模糊度的确定是关键。整周模糊度的主要作用是用来计算站星几何距离，高精度的站星几何距离才能获取高精度的解算结果。

**2. 部分模糊度固定**

理论上，正确固定的模糊度数越多，定位精度和可靠性越高，然而需要指出的是，整体模糊度固定(Full Ambiguity Resolution, FAR)并不总是最优的选择。随着多频多系统的发展，有效观测值数量显著增加，致使模糊度参数的维度陡增，极大增加了整体模糊度固定的难度，使得模糊度固定的成功率和可靠性都显著下降。目前的部分模糊度固定算法归纳起来可大致分为三类：

- 根据观测值信噪比、卫星高度角等信息对参与固定的模糊度进行排序，选取噪声较小的模糊度参与固定而剔除噪声较大的模糊度参数
- 将各频率的原始模糊度组合成宽窄巷模糊度，固定宽项模糊度后，通过提高窄巷模糊度方差-协方差矩阵的精度来改善窄巷模糊度的固定效果
- 原始模糊度进行降相关处理后，根据一定策略和准则直接选取模糊度的子集进行固定

**3. Ratio factor**

ratio-test用来验证整周模糊度；该值表示具有第二最佳整数向量的残差与最佳整数向量的平方和之比。 

**4. LAMBDA算法固定模糊度**

**a. LAMBDA算法目的**

提高整周模糊度估计和捜索的效率，**减少计算量**。

**b. LAMBDA算法流程**

1. 建立双差方差，最小二乘估计整周模糊度浮点解$N_1$及其协方差矩阵$Q_1$
2. 由$Q_1$构造转换矩阵$Z$
3. 采用$Z$整数转换矩阵将$N_1$和$Q_1$转换成$N_2$和$Q_2$
4. 进行整周模糊度搜索求得$N_2$的整数解$N_3$及其协方差阵$Q_3$
5. 对$N_3$和$Q_3$进行$Z$逆变换得到$N_1$的整数解及其协方差矩阵

**c. LAMBDA算法核心**

- 基于整数变换的模糊度**降相关**——为了保证LAMBDA捜索的快捷性和准确性，需要首先对原始模糊度的协因数矩阵加以调整，使得原始模糊度间的相关性降低。
- 基于**序贯条件最小二乘**估计的整周捜索LAMBDA搜索是整个过程的关键和主体，其主要目的是通过连续的迭代找出最接近真的的模糊度整数值。

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/52c78060560c477689d8c4aaff88cfb6.png" style="zoom: 67%;" />

### 11.6.2 三种模糊度固定选项

**1. continuous**

认为模糊度是连续解，通过前面历元的解算结果滤波提高后续历元模糊度固定精度，相邻历元的无周跳模糊度给与一个极小的过程噪声。固定率不太稳定，有时可能比较高，但大部分情况可能固定率相对较低，可能原因是rtklib数据预处理不够完善，浮点解精度很差。 

**2. instantaneous**

该模式中相邻历元模糊度没有相关性，即每个历元做一个最小二乘，然后直接就去尝试固定模糊度。单历元模式的优势，就是本历元结果仅与当前历元有关，不需要考虑周跳处理问题，不需要考虑滤波发散问题；缺点是未充分利用历元间的相关性。

**3. fix and hold**

该模式是在Continues模式的基础上，如果模糊度固定正确，即会将固定的模糊度约束浮点滤波器。当然，如果模糊度错误固定，会导致浮点解出现较大偏差，导致较长时间的无法固定。

> 一种改进方法是：做工程可做两套，Instantaneous和Fix and Hold，发现Fix and Hold错了，就用Instantaneous的解把它替换掉，相当于把模糊度和方差初始化了一次，避免漂移和模糊度重新收敛的过程。

### 11.6.3 resamb_LAMBDA()：LAMBDA算法入口函数

![img](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/20210628192054418.png) 

**1. 参数列表**

```c
rtk_t *rtk		I	RTK控制结构体
double *bias	O	
double *xa		O 	固定解
```

**2. 执行流程**

- 整周模糊度ratio值`rtk->sol.ratio`赋初值0.0
- 检查配置中所设置的ratio值`rtk->opt.thresar[0]`，如果该阈值小于1，则return 0 
- 调用`ddidx()`函数，创建将卡尔曼状态量从单差转到双差的转换矩阵`D`，主要是将单差相位偏移状态量转换为双差相位偏移 
- 根据转移矩阵，求解双差整周模糊度以及协方差阵
- 调用`lambda()`函数计算双差整周模糊度最优解以及残差。估计结果存在`b`，`s`中 
- 计算Ratio值，如果Ratio值大于阈值，求解固定解rtk->xa以及固定解的协方差rtk->Pa 
- 调用`restamb()`，重新存储单差的模糊度，便于固定解有效性验证

::: details 点击查看完整代码
```c
static int resamb_LAMBDA(rtk_t *rtk, double *bias, double *xa)
{
    prcopt_t *opt=&rtk->opt;
    int i,j,nb,info,nx=rtk->nx,na=rtk->na;
    double *DP,*y,*b,*db,*Qb,*Qab,*QQ,s[2];
    int *ix;

    trace(3,"resamb_LAMBDA : nx=%d\n",nx);
    
    //整周模糊度ratio赋初值0.0
    rtk->sol.ratio=0.0;
    
    //检查配置中所设置的ratio值，如果该阈值小于1，则return 0
    if (rtk->opt.mode<=PMODE_DGPS||rtk->opt.modear==ARMODE_OFF||
        rtk->opt.thresar[0]<1.0) {
        return 0;
    }

    //调用ddidx()函数，创建将卡尔曼状态量从单差转到双差的转换矩阵D
    //主要是将单差相位偏移状态量转换为双差相位偏移
    /* index of SD to DD transformation matrix D */
    ix=imat(nx,2);
    if ((nb=ddidx(rtk,ix))<=0) {
        errmsg(rtk,"no valid double-difference\n");
        free(ix);
        return 0;
    }

    //na实际就是之前卡尔曼滤波中除了单差相位偏移之外的所有状态量个数（例如：位置+速度+加速度+电离层+对流层……）
    //nb则是双差相位偏移的个数（即需要解算的整周模糊度个数）
    y=mat(nb,1); DP=mat(nb,nx-na); b=mat(nb,2); db=mat(nb,1); Qb=mat(nb,nb);
    Qab=mat(na,nb); QQ=mat(na,nb);
    
    //根据转移矩阵，求解双差整周模糊度以及协方差阵
    /* y=D*xc, Qb=D*Qc*D', Qab=Qac*D' */    //(E.7.15) (E.7.16) 
    for (i=0;i<nb;i++) {
        y[i]=rtk->x[ix[i*2]]-rtk->x[ix[i*2+1]]; 
    }
    //
    for (j=0;j<nx-na;j++) for (i=0;i<nb;i++) {
        DP[i+j*nb]=rtk->P[ix[i*2]+(na+j)*nx]-rtk->P[ix[i*2+1]+(na+j)*nx];
    }
    //整周的协方差阵
    for (j=0;j<nb;j++) for (i=0;i<nb;i++) {
        Qb[i+j*nb]=DP[i+(ix[j*2]-na)*nb]-DP[i+(ix[j*2+1]-na)*nb];
    }
    //整周和状态
    for (j=0;j<nb;j++) for (i=0;i<na;i++) {
        Qab[i+j*na]=rtk->P[i+ix[j*2]*nx]-rtk->P[i+ix[j*2+1]*nx];
    }

    //调用lambda()函数计算双差整周模糊度最优解以及残差。估计结果存在b，s中
    /* LAMBDA/MLAMBDA ILS (integer least-square) estimation */
    if (!(info=lambda(nb,2,y,Qb,b,s))) {
        trace(4,"N(1)="); tracemat(4,b   ,1,nb,10,3);
        trace(4,"N(2)="); tracemat(4,b+nb,1,nb,10,3);
        
        //计算Ratio值
        rtk->sol.ratio=s[0]>0?(float)(s[1]/s[0]):0.0f;
        if (rtk->sol.ratio>999.9) rtk->sol.ratio=999.9f;
        
        //如果Ratio值大于阈值，求解固定解rtk->xa以及固定解的协方差rtk->Pa
        /* validation by popular ratio-test */
        if (s[0]<=0.0||s[1]/s[0]>=opt->thresar[0]) {    
            
            /* transform float to fixed solution (xa=xa-Qab*Qb\(b0-b)) */
            for (i=0;i<na;i++) {
                rtk->xa[i]=rtk->x[i];
                for (j=0;j<na;j++) rtk->Pa[i+j*na]=rtk->P[i+j*nx];
            }
            for (i=0;i<nb;i++) {
                bias[i]=b[i];
                y[i]-=b[i];
            }
            if (!matinv(Qb,nb)) {
                matmul("NN",nb,1,nb, 1.0,Qb ,y,0.0,db);
                matmul("NN",na,1,nb,-1.0,Qab,db,1.0,rtk->xa);
                
                /* covariance of fixed solution (Qa=Qa-Qab*Qb^-1*Qab') */
                matmul("NN",na,nb,nb, 1.0,Qab,Qb ,0.0,QQ);
                matmul("NT",na,na,nb,-1.0,QQ ,Qab,1.0,rtk->Pa);
                
                trace(3,"resamb : validation ok (nb=%d ratio=%.2f s=%.2f/%.2f)\n",
                      nb,s[0]==0.0?0.0:s[1]/s[0],s[0],s[1]);
                
                //调用restamb()，重新存储单差的模糊度
                /* restore SD ambiguity */
                restamb(rtk,bias,nb,xa);
            }
            else nb=0;
        }
        else { /* validation failed */
            errmsg(rtk,"ambiguity validation failed (nb=%d ratio=%.2f s=%.2f/%.2f)\n",
                   nb,s[1]/s[0],s[0],s[1]);
            nb=0;
        }
    }
    else {
        errmsg(rtk,"lambda error (info=%d)\n",info);
        nb=0;
    }
    free(ix);
    free(y); free(DP); free(b); free(db); free(Qb); free(Qab); free(QQ);
    
    return nb; /* number of ambiguities */
}
```
:::

### 11.6.4 lambda()：lambda整数最小二乘估计

**1. 参数列表**：

```c
int    n      I  number of float parameters      //浮点解数量
int    m      I  number of fixed solutions       //固定解数量
double *a     I  float parameters (n x 1)        //浮点参数向量
double *Q     I  covariance matrix of float parameters (n x n)   //浮点参数协方差阵
double *F     O  fixed solutions (n x m)     	//固定解
double *s     O  sum of squared residulas of fixed solutions (1 x m) //总固定残差向量
```

**2. 执行流程**：

- 调用`LD()`，首先对浮点协方差阵进行LD分解
- 调用`reduction()`，lambda降相关性
- z变换，将双差模糊度进行变换
- 调用`search()`,mlambda search，结果存储在`E`和`s`中（整数解） 
- 调用`solve()`，逆Z变换，将在新空间中固定的模糊度逆变换回双差模糊度空间中，存储在`F`中 

::: details 点击查看完整代码
```c
extern int lambda(int n, int m, const double *a, const double *Q, double *F,
                  double *s)
{
    int info;
    double *L,*D,*Z,*z,*E;
    
    if (n<=0||m<=0) return -1;
    L=zeros(n,n); D=mat(n,1); Z=eye(n); z=mat(n,1); E=mat(n,m);
    
    //调用LD()，首先对浮点协方差阵进行LD分解
    /* LD factorization */
    if (!(info=LD(n,Q,L,D))) {

        //调用reduction()，lambda降相关性
        /* lambda reduction */
        reduction(n,L,D,Z);

        // z变换，将双差模糊度进行变换
        matmul("TN",n,1,n,1.0,Z,a,0.0,z); /* z=Z'*a */
        
        //调用search(),mlambda search，结果存储在E和s中（整数解）
        /* mlambda search */
        if (!(info=search(n,m,L,D,z,E,s))) {
            //逆Z变换，将在新空间中固定的模糊度逆变换回双差模糊度空间中，存储在F中
            info=solve("T",Z,E,n,m,F); /* F=Z'\E */
        }
    }
    free(L); free(D); free(Z); free(z); free(E);
    return info;
}
```
:::

### 11.6.5 reduction()：LAMBDA降相关

```c
static void reduction(int n, double *L, double *D, double *Z)
{
    int i,j,k;
    double del;
    
    j=n-2; k=n-2;   //调序变换
    
    //对第0,1，...，k-1，k列进行降相关
    while (j>=0) {
        if (j<=k) for (i=j+1;i<n;i++) gauss(n,L,Z,i,j); //从最后一列开始，各列非对角线元素从上往下依次降相关
        del=D[j]+L[j+1+j*n]*L[j+1+j*n]*D[j+1];
        //检验条件，若不满足检验条件则开始进行调序变换
        if (del+1E-6<D[j+1]) { /* compared considering numerical error */
            perm(n,L,D,j,del,Z);
            k=j; j=n-2; //完成调序变换后重新从最后一列开始进行降相关及排序，k记录最后一次进行过调序变换的列序号
        }
        else j--;
    }
}
```

### 11.6.6 gauss()：整数高斯变换

```c
static void gauss(int n, double *L, double *Z, int i, int j)
{
    int k,mu;
    
    if ((mu=(int)ROUND(L[i+j*n]))!=0) {
        for (k=i;k<n;k++) L[k+n*j]-=(double)mu*L[k+i*n];
        for (k=0;k<n;k++) Z[k+n*j]-=(double)mu*Z[k+i*n];
    }
}
```

### 11.6.7 perm()：条件方差重新排列

```c
static void perm(int n, double *L, double *D, int j, double del, double *Z)
{
    int k;
    double eta,lam,a0,a1;
    
    eta=D[j]/del;
    lam=D[j+1]*L[j+1+j*n]/del;
    D[j]=eta*D[j+1]; D[j+1]=del;
    for (k=0;k<=j-1;k++) {
        a0=L[j+k*n]; a1=L[j+1+k*n];
        L[j+k*n]=-L[j+1+j*n]*a0+a1;
        L[j+1+k*n]=eta*a0+lam*a1;
    }
    L[j+1+j*n]=lam;
    for (k=j+2;k<n;k++) SWAP(L[k+j*n],L[k+(j+1)*n]);
    for (k=0;k<n;k++) SWAP(Z[k+j*n],Z[k+(j+1)*n]);
}
```

### 11.6.8 search()：mlambda搜索

```c
static int search(int n, int m, const double *L, const double *D,
                  const double *zs, double *zn, double *s)
{
    int i,j,k,c,nn=0,imax=0;
    double newdist,maxdist=1E99,y;
    double *S=zeros(n,n),*dist=mat(n,1),*zb=mat(n,1),*z=mat(n,1),*step=mat(n,1);
    
    k=n-1; dist[k]=0.0; //k表示当前层，从最后一层（n-1）开始计算
    zb[k]=zs[k];//即zn
    z[k]=ROUND(zb[k]); y=zb[k]-z[k]; step[k]=SGN(y);    //四舍五入取整；取整后的数与未取整的数作差；step记录z[k]是四舍还是五入
    for (c=0;c<LOOPMAX;c++) {
        newdist=dist[k]+y*y/D[k];
        if (newdist<maxdist) {      //如果当前累积目标函数计算值小于当前超椭圆半径
            //情况1：若还未计算至第一层，继续计算累积目标函数值
            if (k!=0) { 
                dist[--k]=newdist;  //记录下当前层的累积目标函数值，dist[k]表示了第k,k+1,...,n-1层的目标函数计算和
                for (i=0;i<=k;i++)
                    S[k+i*n]=S[k+1+i*n]+(z[k+1]-zb[k+1])*L[k+1+i*n];
                zb[k]=zs[k]+S[k+k*n];   //计算Zk，即第k个整数模糊度参数的备选组的中心
                z[k]=ROUND(zb[k]); y=zb[k]-z[k]; step[k]=SGN(y);    //四舍五入取整；取整后的数与未取整的数作差；记录是四舍还是五入
            }
            //情况2：若已经计算至第一层，意味着所有层的累积目标函数值计算完毕
            else {
                //nn为当前候选解数，m为我们需要的固定解数，这里为2，表示需要一个最优解及一个次优解
                //s记录候选解的目标函数值，imax记录之前候选解中的最大目标函数值的坐标
                if (nn<m) { //若候选解数还没满
                    if (nn==0||newdist>s[imax]) imax=nn;    //若当前解的目标函数值比之前最大的目标函数值都大，那么更新imax使s[imax]指向当前解中具有的最大目标函数值
                    for (i=0;i<n;i++) zn[i+nn*n]=z[i];  //zn存放所有候选解
                    s[nn++]=newdist;    //s记录当前目标函数值newdist，并加加当前候选解数nn
                }
                else {  //若候选解数已满（即当前zn中已经存了2个候选解）
                    if (newdist<s[imax]) {  //若当前解的目标函数值比s中的最大目标函数值 
                        for (i=0;i<n;i++) zn[i+imax*n]=z[i];    //用当前解替换zn中具有较大目标函数值的解
                        s[imax]=newdist;    //用当前解的目标函数值替换s中的最大目标函数值
                        for (i=imax=0;i<m;i++) if (s[imax]<s[i]) imax=i;    //更新imax保证imax始终指向s中的最大目标函数值
                    }
                    maxdist=s[imax];    //用当前最大的目标函数值更新超椭圆半径
                }
                //在第一层，取下一个有效的整数模糊度参数进行计算（若zb为5.3，则z取值顺序为5,6,4,7，...）
                z[0]+=step[0]; y=zb[0]-z[0]; step[0]=-step[0]-SGN(step[0]);
            }
        }
        //情况3：如果当前累积目标函数计算值大于当前超椭圆半径
        else {
            if (k==n-1) break;  //如果当前层为第n-1层，意味着后续目标函数各项的计算都会超出超椭圆半径，因此终止搜索
            else {  //若当前层不是第n-1层
                k++;    //退后一层，即从第k层退到第k+1层
                z[k]+=step[k]; y=zb[k]-z[k]; step[k]=-step[k]-SGN(step[k]); //计算退后一层后，当前层的下一个有效备选解
            }
        }
    }
    // 对s中的目标函数值及zn中的候选解进行排序（以s中目标函数值为排序标准，进行升序排序）
    // RTKLIB中最终可以得到一个最优解一个次优解，存在zn中，两解对应的目标函数值，存在s中
    for (i=0;i<m-1;i++) { /* sort by s */
        for (j=i+1;j<m;j++) {
            if (s[i]<s[j]) continue;
            SWAP(s[i],s[j]);
            for (k=0;k<n;k++) SWAP(zn[k+i*n],zn[k+j*n]);
        }
    }
    free(S); free(dist); free(zb); free(z); free(step);
    
    if (c>=LOOPMAX) {
        fprintf(stderr,"%s : search loop count overflow\n",__FILE__);
        return -1;
    }
    return 0;
}
```

### 11.6.9 holdamb()：Fix and hold模式下模糊度保持

**执行流程**：

- 传入`resamb_LAMBDA()`计算的当前时刻固定解`xa`
- 循环遍历各个卫星，查找满足条件的卫星，并设置相应标志位`rtk->ssat[i].fix=3`
- 计算固定解双差和浮点解双差 的差值，形成量测信息，并更新`H`阵 
- 若观测量数量有效，构建`R`矩阵阵，调用`filter()`量测更新 

```c
static void holdamb(rtk_t *rtk, const double *xa)
{
    double *v,*H,*R;
    int i,n,m,f,info,index[MAXSAT],nb=rtk->nx-rtk->na,nv=0,nf=NF(&rtk->opt);
    
    trace(3,"holdamb :\n");
    
    v=mat(nb,1); H=zeros(nb,rtk->nx);
    
    //循环遍历各个卫星，查找满足条件的卫星，并设置相应标志位rtk->ssat[i].fix=3
    for (m=0;m<5;m++) for (f=0;f<nf;f++) {
        
        for (n=i=0;i<MAXSAT;i++) {
            if (!test_sys(rtk->ssat[i].sys,m)||rtk->ssat[i].fix[f]!=2||
                rtk->ssat[i].azel[1]<rtk->opt.elmaskhold) {
                continue;
            }
            index[n++]=IB(i+1,f,&rtk->opt);
            rtk->ssat[i].fix[f]=3; /* hold */
        }
        //计算固定解双差和浮点解双差 的差值，形成量测信息，并更新H阵
        /* constraint to fixed ambiguity */
        for (i=1;i<n;i++) {
            //xa为固定解、rtk->x为浮点解
            v[nv]=(xa[index[0]]-xa[index[i]])-(rtk->x[index[0]]-rtk->x[index[i]]);
            
            H[index[0]+nv*rtk->nx]= 1.0;
            H[index[i]+nv*rtk->nx]=-1.0;
            nv++;
        }
    }
    //若观测量数量有效，设置R阵，并调用filter()量测更新
    if (nv>0) {
        R=zeros(nv,nv);
        for (i=0;i<nv;i++) R[i+i*nv]=VAR_HOLDAMB;
        
        /* update states with constraints */
        if ((info=filter(rtk->x,rtk->P,H,v,R,rtk->nx,nv))) {
            errmsg(rtk,"filter error (info=%d)\n",info);
        }
        free(R);
    }
    free(v); free(H);
}
```

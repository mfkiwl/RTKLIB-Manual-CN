## 11.7 detslp_*(): 周跳探测

### 11.7.1 周跳探测与修复概念

周跳的探测与修复就是运用一定的方法探测出在何时发生了整周跳变，并求出丢失的整周数，然后将中断后的整周计数恢复为正确的计数，使这部分观测值正常使用。

**1. 周跳产生原因**

- 在GNSS测量中，接收机开机时，观测拍频的小数部分，并初始化整周计数。连续跟踪的情况下，小数部分的相位从$2\pi$变成０时计数器加１。
- 因此，在某一给定的历元下，观测的累积相位$\Delta_\phi$等于相位整周计数N加上小数部分。**整周数Ｎ被认为是一个未知数**。在接收载波信号过程中不发生失锁的倩况下，整周数Ｎ就一直保持某一固定值。
- 当**累积相位出现整周数的跳变时，整周计数就要重新进行初始化**。由于卫星信号受到阻挡等原因而导致**卫星信号失锁**，当某个历元载波信号重新被接收到后，计数器整周计数丢失，整周数发生错误，但小数部分仍然是正确的，这就是周跳现象。
- 引起整周计数中断原因主要有：
  - **信号遮挡**（特别是基于载波相位的动态定位）
  - **低信噪比**，如恶劣的电离层条件、多路径效应、接收机的高速运动或者卫星高度角过低
  - 接收机软件问题、卫星振荡器故障

**2. 周跳对定位精度的影响**

- 观测数据中大于10周的周跳，在数据预处理时不难发现，可Ｗ消除。而对于小于10周的周跳，特别是1-5周的周跳，以及半周跳和1/4周跳不易发现，而对含有周跳的观测值，周跳的影响视为观测的偶然误差，因而严重影响测量的精度。
- 即使**只有一颗卫星存在一个周跳，也会对测点产生几厘米的误差**。一个点位坐标是由４颗上卫星所确定的，故周跳对点位坐标的影响取决于卫星数、几何结构、周跳影响各分量的大小和周跳次数。
- 凡精度要求达到厘米级或分米级的GNSS测量，都必须将观测数据中的周跳全部清除。

**3. 周跳检验量**

- 载波相位观测量的时间序列，表现出来的是一条随时间变化的**光滑曲线**，因为整周模糊度不随时间变化，一旦出现周跳，这种光滑性就被破坏，而且自该历元起，后继历元相位观测值序列均发生**等量阶跃**。
- **判读周跳实质上就是探测观测序列是否发生阶跃突变**，在探测之前最好能尽量**消除**观测序列中的各项**误差项**，使得观测序列能准确反映出周跳的变化。
- 由载波相位的观测方程可知，在方程中随时间变化的项主要有接收机至卫星间的几何距离、接收机和卫星的钟差以及及大气层延迟等三项。**对GNSS观测值进行适当的組合，将上面三项中的大部分误差消除，即可构成周跳检测量**。

![](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/da426007994d49c2b09ab1c918aeb42d.png)

**4. LLI：失锁标识符**

> 参考博客：[周跳探测——LLI](http://t.csdn.cn/TXAze)

- 范围为0-7，对应二进制数000-111；有三个位，其中bit0、bit1仅用于相位
- 0或空格：正常或未知
- **Bit0**：先前与当前观测值之间失锁，可能发生了周跳（只针对相位观测值）
- **Bit1**：接收机进行半周模糊度解算，或程序不能处理半周数据而跳过该观测值的记录（只对当前历元有效）
- **Bit2**：bit 2置1表示为反欺骗(AS)下的观测值(可能会受到噪声增加的影响) 
- 理论上只要板卡足够好，它自身的LLI标志就能把载波数据的周跳、半周跳告知你，就不需要其他探测方法了。LLI的是从信道方面探测周跳的，效果应该比我们从数据方法探测周跳更灵敏。
- 有的板卡或许LLI探测太灵敏了，把没有问题的数据也当作周跳进行标志，可能会导致观测数据不足，故有时会把LLI周跳探测方法关闭。   

### 11.7.2 detslp_ll()：根据LLI进行周跳检测

```c
static void detslp_ll(rtk_t *rtk, const obsd_t *obs, int i, int rcv)
{
    uint32_t slip,LLI;
    int f,sat=obs[i].sat;
    
    trace(3,"detslp_ll: i=%d rcv=%d\n",i,rcv);
    
    //nf是频点个数(1:L1,2:L1+L2,3:L1+L2+L5)
    for (f=0;f<rtk->opt.nf;f++) {
        
        if (obs[i].L[f]==0.0||
            fabs(timediff(obs[i].time,rtk->ssat[sat-1].pt[rcv-1][f]))<DTTOL) {
            continue;
        }
        /* restore previous LLI */
        if (rcv==1) LLI=getbitu(&rtk->ssat[sat-1].slip[f],0,2); /* rover */
        else        LLI=getbitu(&rtk->ssat[sat-1].slip[f],2,2); /* base  */
        
        /* detect slip by cycle slip flag in LLI */
        if (rtk->tt>=0.0) { /* forward */
            //bit0为1，表明当前历元可能发生了周跳
            if (obs[i].LLI[f]&1) {  
                errmsg(rtk,"slip detected forward  (sat=%2d rcv=%d F=%d LLI=%x)\n",
                       sat,rcv,f+1,obs[i].LLI[f]);
            }
            slip=obs[i].LLI[f];
        }
        else { /* backward */
            //前一历元bit0位为1，表明前一历元发生可能发生了周跳
            if (LLI&1) {
                errmsg(rtk,"slip detected backward (sat=%2d rcv=%d F=%d LLI=%x)\n",
                       sat,rcv,f+1,LLI);
            }
            slip=LLI;
        }
        /* detect slip by parity unknown flag transition in LLI */
        //(LLI&2)&&!(obs[i].LLI[f]&2)--前一历元bit1 位为1并且当前历元bit1位不为1
        //(!(LLI&2)&&(obs[i].LLI[f]&2) ----前一历元bit1 位为0且当前历元bit1位为1
        //即前后历元的bit1位不相同，表明可能发生了半周跳。
        if (((LLI&2)&&!(obs[i].LLI[f]&2))||(!(LLI&2)&&(obs[i].LLI[f]&2))) {
            errmsg(rtk,"slip detected half-cyc (sat=%2d rcv=%d F=%d LLI=%x->%x)\n",
                   sat,rcv,f+1,LLI,obs[i].LLI[f]);
            slip|=1;
        }
        /* save current LLI */
        if (rcv==1) setbitu(&rtk->ssat[sat-1].slip[f],0,2,obs[i].LLI[f]);
        else        setbitu(&rtk->ssat[sat-1].slip[f],2,2,obs[i].LLI[f]);
        
        /* save slip and half-cycle valid flag */
        rtk->ssat[sat-1].slip[f]|=(uint8_t)slip;
        rtk->ssat[sat-1].half[f]=(obs[i].LLI[f]&2)?0:1;
    }
}
```

### 11.7.3 detslp_gf()：利用几何无关组合进行周跳检测

> 需要双频

![](https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/48ba3d892a474c9fb8765baf5a2b9a3d.png)


上式理论等于0，若不为0（大于阈值0.05m），则认为检测到了周跳

```c
static void detslp_gf(rtk_t *rtk, const obsd_t *obs, int i, int j,
                      const nav_t *nav)
{
    int k,sat=obs[i].sat;
    double g0,g1;
    
    trace(3,"detslp_gf: i=%d j=%d\n",i,j);
    
    for (k=1;k<rtk->opt.nf;k++) {
        if ((g1=gfobs(obs,i,j,k,nav))==0.0) return;
         
        g0=rtk->ssat[sat-1].gf[k-1];
        rtk->ssat[sat-1].gf[k-1]=g1;
         
        if (g0!=0.0&&fabs(g1-g0)>rtk->opt.thresslip) {
            rtk->ssat[sat-1].slip[0]|=1;
            rtk->ssat[sat-1].slip[k]|=1;
            errmsg(rtk,"slip detected GF jump (sat=%2d L1-L%d GF=%.3f %.3f)\n",
                   sat,k+1,g0,g1);
        }
    }
}
```

### 11.7.4 gfobs()：求几何无关组合观测值

```c
static double gfobs(const obsd_t *obs, int i, int j, int k, const nav_t *nav)
{
    double freq1,freq2,L1,L2;
    
    freq1=sat2freq(obs[i].sat,obs[i].code[0],nav);
    freq2=sat2freq(obs[i].sat,obs[i].code[k],nav);
    L1=sdobs(obs,i,j,0);
    L2=sdobs(obs,i,j,k);
    if (freq1==0.0||freq2==0.0||L1==0.0||L2==0.0) return 0.0;
    return L1*CLIGHT/freq1-L2*CLIGHT/freq2;
}
```
